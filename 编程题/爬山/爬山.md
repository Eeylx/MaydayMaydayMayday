# 爬山
> 百度 2018春招 机器学习/数据挖掘/自然语言处理 

时间限制: C/C++ 2000 MS, 其他语言 4000 MS    
内存限制: C/C++ 65536 KB, 其他语言 589824 KB

## 描述
冬木市西边的圆藏山是著名的旅游圣地. 从空中俯瞰, 圆藏山可以看成一个 n * m 的矩阵, 
我们把行从上往下按1到n编号, 把列从左往右按1到m编号, 那么(i, j)就表示矩阵第 i 行第 j 列的位置. 
我们用h(i,j)表示位置(i, j)的海拔高度.

初始时, Saber在(sx, xy)这个位置, 她想前往更高的地方. 
每一次她可以选择向上, 下, 左, 右其中一个方向走, 但不能走出这个矩阵.
同时, 作为大不列颠的王, 孤傲的Saber不愿意走到比她当前所在位置的海拔更低的位置, 
也就是说在移动过程中, 每一步她都只能向海拔不低于她当前所在位置的那些位置移动.

请你帮忙计算她所能走到的最高高度.

## 输入
第一行包含两个整数n, m, 表示矩阵的规模 (1 <= n, m <= 200).

第二行包含两个整数sx, sy, 表示初始时Saber的位置 (1 <= sx <= n, 1 <= sy <= m).

接下来n行每行包含m个数字, 表示位置(i, j)的海拔高度 (0 <= h(i,j) <= 10^9).

## 输出
输出Saber能够移动到的最高高度.

### 样例输入1
    2 2
    1 1
    2 1
    1 3

### 样例输出1
    2

### 样例输入2
    2 3
    1 1
    1 5 2
    0 4 9

### 样例输出2
    5


[代码]()
```c++
#include <iostream>
using namespace std;

enum action {
	init, goUp, goDown, goLeft, goRight
};

// 返回四个结果中的最大值 
int maxResult(int upResult, int downResult, int leftResult, int rightResult) {
	int result = 0;

	if (result < upResult)
		result = upResult;

	if (result < downResult)
		result = downResult;

	if (result < leftResult)
		result = leftResult;

	if (result < rightResult)
		result = rightResult;

	return result;
}

// 如果有更高的位置就往过走, 无处可去则返回自身所在位置的高度
//  arr: 二维数组; n, m: 二维数组行列; i, j: 当前位置; lastAction: 上一步的行动 
int doClimb(int** arr, int n, int m, int i, int j, int lastAction) {
	// 如果 
	if ((i == 0 || arr[i - 1][j] < arr[i][j]) &&					// 不能往上走
		(i == n - 1 || arr[i + 1][j] < arr[i][j]) &&				// 不能往下走
		(j == 0 || arr[i][j - 1] < arr[i][j]) &&					// 不能往左走
		(j == m - 1 || arr[i][j + 1] < arr[i][j])) {				// 不能往右走 
		return arr[i][j];										// 返回当前位置的高度 
	}

	int upResult = 0, downResult = 0, leftResult = 0, rightResult = 0;

	if (!(i == 0 || arr[i - 1][j] < arr[i][j])) {				// 能往上走 
		if (lastAction != goDown) {									// 上一步不是往下走(防止循环) 
			upResult = doClimb(arr, n, m, i - 1, j, goUp);			// 往上走 
		}														// 下同 
	}

	if (!(i == n - 1 || arr[i + 1][j] < arr[i][j])) {
		if (lastAction != goUp) {
			downResult = doClimb(arr, n, m, i + 1, j, goDown);		// 往下走 
		}
	}

	if (!(j == 0 || arr[i][j - 1] < arr[i][j])) {
		if (lastAction != goRight) {
			leftResult = doClimb(arr, n, m, i, j - 1, goLeft);		// 往左走 
		}
	}

	if (!(j == m - 1 || arr[i][j + 1] < arr[i][j])) {
		if (lastAction != goLeft) {
			rightResult = doClimb(arr, n, m, i, j + 1, goRight);	// 往右走 
		}
	}

	return maxResult(upResult, downResult, leftResult, rightResult);
}

int main() {
	int n = 0, m = 0;
	int posi = 0, posj = 0;
	int i = 0, j = 0;

	cin >> n >> m;					// n行m列 
	cin >> posi >> posj;			// 初始位置

	int** arr = new int*[n];	// 申请n行m列的二维数组
	for (i = 0; i<n; i++) {
		arr[i] = new int[m];

		for (j = 0; j<m; j++)		// 输入对应的高度 
			cin >> arr[i][j];
	}

	cout << doClimb(arr, n, m, posi-1, posj-1, init);	// 题目中第一行列是1, 但数组下标是0

	for (i = 0; i<n; i++)
		delete[] arr[i];
	delete[] arr;

	// system("pause");
	return 0;
}

```